## 1.关于this

### 1.1为什么要用this

> this提供了一种更优雅的方式来隐式传递一个对象引用
>

### 1.2误解

#### 1.2.1 指向自身

**demo1**:

```js
function foo(num){
	console.log(num);
	this.count++;
}
foo.count = 0;

var i = 0;

for(i=0; i < 10; i++){
	if(i>5){
		foo(i)
	}
}
console.log(foo.count) //0
```

解析：foo函数的调用对象是window，故在执行foo函数内部的this.count++时，this指向window对象

this在任何情况下都不指向函数的词法作用域

> **总结**：对象内部的this指向对象本身，函数内部的this指向函数调用时的作用域

当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入参数等信息。this就是这个记录的一个属性



## 2.全面解析this

### 2.1调用位置

​		我们关心的调用位置就在当前正在执行的函数的前一个调用中

### 2.2 绑定规则

> #### 2.2.1默认绑定
>
> 1）独立函数调用
>
> #### 2.2.2隐式绑定
>
> 调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含
>
> 隐式丢失：当把函数作为参数传入时，可能会发生隐式绑定丢失
>
> #### 2.2.3 显示绑定
>
> 使用call、apply、bind
>
> 1）硬绑定
>
> 2）API调用的上下文
>
> #### 2.2.4 new绑定
>
> this会被绑定到这个通过new创建的新对象上
>

### 2.3优先级

new 显示绑定 隐式绑定 默认绑定

## 2.4绑定例外

### 2.4.1被忽略的this

### 2.4.2间接引用

对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象

## 2.5 this词法

箭头函数的this，继承外层函数调用的this绑定（无论this绑定到什么）

```js
function foo（）｛
    return (a) => {
        console.log(this.a);
    }
}

var obj1 = {
	a:2
}

var obj2 = {
	a:3
}

var bar = foo.call(obj1)

bar.call(obj2) //2
```

如果内层函数不是一个箭头函数

## 2.this与绑定

`this`的5种绑定方式：

- 默认绑定(非严格模式下this指向全局对象, 严格模式下`this`会绑定到`undefined`)

- 隐式绑定(当函数引用有**上下文对象**时, 如 `obj.foo()`的调用方式, `foo`内的`this`指向`obj`)

- 显示绑定(通过`call()`或者`apply()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`)

- new绑定

- 箭头函数绑定(`this`的指向由外层作用域决定的)

### 1.默认绑定

在非严格模式下`this`指向的是全局对象`window`，而在严格模式下会绑定到`undefined`。

### 2.隐式绑定

**this 永远指向最后调用它的那个对象**

有两种情况容易发生隐式丢失问题：

- 使用另一个变量来给函数取别名

- 将函数作为参数传递时会被隐式赋值，回调函数丢失this绑定

### 3.显示绑定

通过`call()、apply()`或者`bind()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`。

这里有几个知识点需要注意：

- 使用`.call()`或者`.apply()`的函数是会直接执行的

- `bind()`是创建一个新的函数，需要手动调用才会执行

- `.call()`和`.apply()`用法基本类似，不过`call`接收若干个参数，而`apply`接收的是一个数组

- `this` 永远指向最后调用它的那个对象

- 匿名函数的`this`永远指向`window`

- 如果`call、apply、bind`接收到的第一个参数是空或者`null、undefined`的话，则会忽略这个参数

- `forEach、map、filter`函数的第二个参数也是能显式绑定`this`的

### 4.new绑定

使用`new`来调用一个函数，会构造一个新对象并把这个新对象绑定到调用函数中的`this`。

### 5.箭头函数绑定

- 它里面的`this`是由外层作用域来决定的，且指向函数定义时的`this`而非执行时

- 字面量创建的对象，作用域是`window`，如果里面有箭头函数属性的话，`this`指向的是`window`

- 构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的`this`是指向新建的对象的，因此`this`指向这个对象。

- 箭头函数的`this`是无法通过`bind、call、apply`来**直接**修改，但是可以通过改变作用域中`this`的指向来间接修改。

**优点**

- 箭头函数写代码拥有更加简洁的语法(当然也有人认为这是缺点)

- `this`由外层作用域决定，所以在某些场合我们不需要写类似`const that = this`这样的代码

### 王者一练

```text
function foo() {

  console.log( this.a );
}
var a = 2;
(function(){
  "use strict";
  foo();
})();
```
