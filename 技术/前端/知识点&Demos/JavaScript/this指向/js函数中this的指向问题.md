## 1.关于this

### 1.1为什么要用this

> this提供了一种更优雅的方式来隐式传递一个对象引用
>

### 1.2误解

#### 1.2.1 指向自身

**demo1**:

```js
function foo(num){
	console.log(num);
	this.count++;
}
foo.count = 0;

var i = 0;

for(i=0; i < 10; i++){
	if(i>5){
		foo(i)
	}
}
console.log(foo.count) //0
```

解析：foo函数的调用对象是window，故在执行foo函数内部的this.count++时，this指向window对象

this在任何情况下都不指向函数的词法作用域

> **总结**：对象内部的this指向对象本身，函数内部的this指向函数调用时的作用域

当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入参数等信息。this就是这个记录的一个属性



## 2.全面解析this

### 2.1调用位置

​		我们关心的调用位置就在当前正在执行的函数的前一个调用中

### 2.2 绑定规则

> #### 2.2.1默认绑定
>
> 1）独立函数调用
>
> #### 2.2.2隐式绑定
>
> 调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含
>
> 隐式丢失：当把函数作为参数传入时，可能会发生隐式绑定丢失
>
> #### 2.2.3 显示绑定
>
> 使用call、apply、bind
>
> 1）硬绑定
>
> 2）API调用的上下文
>
> #### 2.2.4 new绑定
>
> this会被绑定到这个通过new创建的新对象上
>

### 2.3优先级

new 显示绑定 隐式绑定 默认绑定

## 2.4绑定例外

### 2.4.1被忽略的this

### 2.4.2间接引用

对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象

## 2.5 this词法

箭头函数的this，继承外层函数调用的this绑定（无论this绑定到什么）

```js
function foo（）｛
    return (a) => {
        console.log(this.a);
    }
}

var obj1 = {
	a:2
}

var obj2 = {
	a:3
}

var bar = foo.call(obj1)

bar.call(obj2) //2
```

如果内层函数不是一个箭头函数